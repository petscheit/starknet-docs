<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Syntax &#8212; Cairo Documentation (Cairo 0)  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Common Library" href="common_library.html" />
    <link rel="prev" title="Reference" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="syntax">
<h1>Syntax<a class="headerlink" href="#syntax" title="Link to this heading">¶</a></h1>
<p>This page summarizes the syntax of Cairo. For more information, refer to the “Hello, Cairo”
and “How Cairo Works” tutorials.</p>
<section id="comments">
<h2>Comments<a class="headerlink" href="#comments" title="Link to this heading">¶</a></h2>
<p>Text can be inserted into the body of Cairo programs to document notes about the code.
The commented text is annotated with the <code class="docutils literal notranslate"><span class="pre">//</span></code> syntax. Text following it is ignored by
the compiler.</p>
<p>Each comment spreads until the end of the line. In order to write a multiline comment, prefix all
the comment lines with <code class="docutils literal notranslate"><span class="pre">//</span></code>.</p>
</section>
<section id="punctuation">
<h2>Punctuation<a class="headerlink" href="#punctuation" title="Link to this heading">¶</a></h2>
<p>The punctuation marks used in Cairo are described below:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">;</span></code> (semicolon). Used at the end of each instruction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(</span></code> <code class="docutils literal notranslate"><span class="pre">)</span></code> (parentheses, round brackets). Used in a function declaration, <code class="docutils literal notranslate"><span class="pre">if</span></code> statements,
and in a tuple declaration.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{</span></code> <code class="docutils literal notranslate"><span class="pre">}</span></code> (braces, curly braces, curly brackets). Used in a declaration of implicit
arguments and to define a block of code
(e.g., the body of a function, and <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">else</span></code> blocks).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[</span></code> <code class="docutils literal notranslate"><span class="pre">]</span></code> (brackets, square brackets). Standalone brackets represent the value at a
particular address location (such as the allocation pointer, <code class="docutils literal notranslate"><span class="pre">[ap]</span></code>). Brackets following a
pointer or a tuple act as a subscript operator, where <code class="docutils literal notranslate"><span class="pre">x[2]</span></code> represents the element with
index <code class="docutils literal notranslate"><span class="pre">2</span></code> in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">*</span></code> Single asterisk. Refers to the pointer of an expression.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">ap++</span></code> Used to increment the allocation pointer <code class="docutils literal notranslate"><span class="pre">ap</span></code> by one after the preceding
instruction has finished.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%</span></code> Percent sign. Appears at the start of a directive, such as <code class="docutils literal notranslate"><span class="pre">%builtins</span></code> or <code class="docutils literal notranslate"><span class="pre">%lang</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%{</span></code> <code class="docutils literal notranslate"><span class="pre">%}</span></code> Represents Python hints.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_</span></code> (underscore, underline). A placeholder to handle values that are not used, such as an
unused function return value.</p></li>
</ul>
</section>
<section id="type-system">
<span id="syntax-type"></span><h2>Type system<a class="headerlink" href="#type-system" title="Link to this heading">¶</a></h2>
<p>Cairo have the following types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">felt</span></code> – a field element (see <a class="reference internal" href="../how-cairozero-works/cairo_intro.html#field-elements"><span class="std std-ref">Field elements</span></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MyStruct</span></code> where <code class="docutils literal notranslate"><span class="pre">MyStruct</span></code> is a <a class="reference internal" href="#syntax-structs"><span class="std std-ref">struct</span></a> name.</p></li>
<li><p>An unnamed tuple – For example: <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> where <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are types
(see <a class="reference internal" href="#syntax-tuples"><span class="std std-ref">Tuples</span></a>).</p></li>
<li><p>A named tuple – For example: <code class="docutils literal notranslate"><span class="pre">(x:</span> <span class="pre">a,</span> <span class="pre">y:</span> <span class="pre">b)</span></code> where <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are types
(see <a class="reference internal" href="#syntax-tuples"><span class="std std-ref">Tuples</span></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T*</span></code> where <code class="docutils literal notranslate"><span class="pre">T</span></code> is any type – a pointer to type <code class="docutils literal notranslate"><span class="pre">T</span></code>. For example: <code class="docutils literal notranslate"><span class="pre">MyStruct*</span></code> or
<code class="docutils literal notranslate"><span class="pre">felt**</span></code>.</p></li>
</ul>
</section>
<section id="expressions">
<h2>Expressions<a class="headerlink" href="#expressions" title="Link to this heading">¶</a></h2>
<p>An expression in Cairo is one of the following:</p>
<ul class="simple">
<li><p>An integer literal (e.g., <code class="docutils literal notranslate"><span class="pre">5</span></code>). Considered as of type <code class="docutils literal notranslate"><span class="pre">felt</span></code>.</p></li>
<li><p>An identifier (a <a class="reference internal" href="#syntax-const"><span class="std std-ref">constant</span></a> or a <a class="reference internal" href="#syntax-reference"><span class="std std-ref">reference</span></a>).
E.g., <code class="docutils literal notranslate"><span class="pre">my_identifier</span></code>, <code class="docutils literal notranslate"><span class="pre">struct_name.member_name</span></code>, <code class="docutils literal notranslate"><span class="pre">reference_name.member_name</span></code>.</p></li>
<li><p>An address register: <code class="docutils literal notranslate"><span class="pre">ap</span></code> or <code class="docutils literal notranslate"><span class="pre">fp</span></code>. Both have type <code class="docutils literal notranslate"><span class="pre">felt</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">-x</span></code> where <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are expressions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(x)</span></code> where <code class="docutils literal notranslate"><span class="pre">x</span></code> is an expression – same as <code class="docutils literal notranslate"><span class="pre">x</span></code>
(allows to control operator precedence in the expression).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[x]</span></code> where <code class="docutils literal notranslate"><span class="pre">x</span></code> is an expression – represents the value of the member at the address <code class="docutils literal notranslate"><span class="pre">x</span></code>.
If <code class="docutils literal notranslate"><span class="pre">x</span></code> is of type <code class="docutils literal notranslate"><span class="pre">T*</span></code> then <code class="docutils literal notranslate"><span class="pre">[x]</span></code> is of type <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;x</span></code> where <code class="docutils literal notranslate"><span class="pre">x</span></code> is an expression – represents the address of the expression <code class="docutils literal notranslate"><span class="pre">x</span></code>.
For example, <code class="docutils literal notranslate"><span class="pre">&amp;[x]</span></code> is <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cast(x,</span> <span class="pre">T)</span></code> where <code class="docutils literal notranslate"><span class="pre">x</span></code> is an expression and <code class="docutils literal notranslate"><span class="pre">T</span></code> is a type – same as <code class="docutils literal notranslate"><span class="pre">x</span></code>, except that
the type is changed to <code class="docutils literal notranslate"><span class="pre">T</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">cast(10,</span> <span class="pre">MyStruct*)</span></code> is <code class="docutils literal notranslate"><span class="pre">10</span></code>, thought as a pointer
to a <code class="docutils literal notranslate"><span class="pre">MyStruct</span></code> instance.</p></li>
</ul>
</section>
<section id="constants">
<span id="syntax-const"></span><h2>Constants<a class="headerlink" href="#constants" title="Link to this heading">¶</a></h2>
<p>You can define a constant value as follows:</p>
<p><code class="docutils literal notranslate"><span class="pre">const_value</span></code> must be an expression that evaluates to an integer (field element) at compile time.
For example: <code class="docutils literal notranslate"><span class="pre">5</span></code> or <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">VAL</span></code> where <code class="docutils literal notranslate"><span class="pre">VAL</span></code> is another constant.</p>
</section>
<section id="references">
<span id="syntax-reference"></span><h2>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<p>A reference can be defined as follows:</p>
<p>where <code class="docutils literal notranslate"><span class="pre">ref_type</span></code> is a type and <code class="docutils literal notranslate"><span class="pre">ref_expr</span></code> is some Cairo expression.</p>
<p>A reference can be rebound, which means that different expressions may be assigned to the same
reference. See <a class="reference internal" href="../how-cairozero-works/consts.html#reference-rebinding"><span class="std std-ref">Reference rebinding</span></a>. For example:</p>
<p>References can be revoked, which means that either:</p>
<ul class="simple">
<li><p>There is a conflict between the expression assigned to a reference at two different places in
the code (for example, due to an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement. See example below).</p></li>
<li><p>The reference is <code class="docutils literal notranslate"><span class="pre">ap</span></code>-based (e.g., temporary variables or return values from a function
call), and the change in ap (between the definition and usage) cannot be deduced at compile
time.</p></li>
</ul>
<p>See <a class="reference internal" href="../how-cairozero-works/consts.html#revoked-references"><span class="std std-ref">Revoked references</span></a> for more information.</p>
</section>
<section id="locals">
<h2>Locals<a class="headerlink" href="#locals" title="Link to this heading">¶</a></h2>
<p>Local variables are defined using the keyword <code class="docutils literal notranslate"><span class="pre">local</span></code>. Cairo places local variables relative to
the frame pointer (<code class="docutils literal notranslate"><span class="pre">fp</span></code>), and thus their values will not be revoked. See <a class="reference internal" href="../how-cairozero-works/consts.html#local-vars"><span class="std std-ref">Local variables</span></a> for more
information.</p>
<p>Any function that uses a local variable must have the <code class="docutils literal notranslate"><span class="pre">alloc_locals;</span></code> statement, usually
at the beginning of the function.
This statement is responsible for allocating the memory cells used by the local
variables within the function’s scope.</p>
<p>In addition, it allows the compiler to allocate local variables for references
that would have otherwise been revoked (see <a class="reference internal" href="../how-cairozero-works/builtins.html#revoked-implicit-arguments"><span class="std std-ref">Revoked implicit arguments</span></a>).
In order to use local variables, without this feature, you can replace the <code class="docutils literal notranslate"><span class="pre">alloc_locals;</span></code>
statement with <code class="docutils literal notranslate"><span class="pre">ap</span> <span class="pre">+=</span> <span class="pre">SIZEOF_LOCALS;</span></code>.</p>
<p>If the address of a local variable is needed, the value of a reference named <code class="docutils literal notranslate"><span class="pre">fp</span></code> must be set to
the value of the frame pointer. This can be done by the statement
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">(__fp__,</span> <span class="pre">_)</span> <span class="pre">=</span> <span class="pre">get_fp_and_pc()</span></code>. See <a class="reference internal" href="../how-cairozero-works/functions.html#retrieving-registers"><span class="std std-ref">Accessing the values of the registers</span></a> for more information.</p>
</section>
<section id="structs">
<span id="syntax-structs"></span><h2>Structs<a class="headerlink" href="#structs" title="Link to this heading">¶</a></h2>
<p>You can define a struct as follows:</p>
<p>Each member is defined using the syntax <code class="docutils literal notranslate"><span class="pre">&lt;member_name&gt;:</span> <span class="pre">&lt;member_type&gt;,</span></code>.</p>
<p>The struct has a size, which is the sum of the sizes of its members.
The size can be retrieved using <code class="docutils literal notranslate"><span class="pre">MyStruct.SIZE</span></code>.</p>
<p>Each member is assigned an offset from the beginning of the struct.
The first member is assigned offset 0,
the second is assigned offset according to the size of the first member and so on.
The offset can be retrieved using <code class="docutils literal notranslate"><span class="pre">MyStruct.member_name</span></code>.
For example, <code class="docutils literal notranslate"><span class="pre">MyStruct.first_member</span> <span class="pre">==</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">MyStruct.second_member</span> <span class="pre">==</span> <span class="pre">1</span></code>
(since the size of <code class="docutils literal notranslate"><span class="pre">felt</span></code> is 1).</p>
</section>
<section id="pointers">
<h2>Pointers<a class="headerlink" href="#pointers" title="Link to this heading">¶</a></h2>
<p>A pointer is used to signify the address of the first field element in the memory of an element.
The pointer can be used to access the element in an efficient manner. For example, a function
may accept a pointer as an argument, and then access the element at the address of the pointer.
The following example shows how to use this type of expression to access a tuple element:</p>
<p>The above example shows how <code class="docutils literal notranslate"><span class="pre">foo()</span></code> accepts a pointer, which is then used to access the tuple.
Passing an argument as a pointer, instead of by value, may be cheaper.</p>
</section>
<section id="struct-constructor">
<h2>Struct constructor<a class="headerlink" href="#struct-constructor" title="Link to this heading">¶</a></h2>
<p>Once a struct has been defined, a constructor can be used to declare an instance of that struct as
follows:</p>
<p>Members must be declared in order of appearance. Struct constructors may be nested as follows:</p>
<p>Where <code class="docutils literal notranslate"><span class="pre">A</span></code> is a struct with members <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">w</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> is a struct with members <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</section>
<section id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="Link to this heading">¶</a></h2>
<p>Arrays can be defined as a pointer (<code class="docutils literal notranslate"><span class="pre">felt*</span></code>) to the first element of the array. As an array is
populated, the elements take up contiguous memory cells. The <code class="docutils literal notranslate"><span class="pre">alloc()</span></code> function is used to
define a memory segment that expands its size whenever each new element in the array is written.</p>
<p>Each element uses the same amount of memory cells and may be accessed by a zero based index
as follows:</p>
<p>Where: (1) the third element in the array is assigned the value <code class="docutils literal notranslate"><span class="pre">85</span></code>, and (2) <code class="docutils literal notranslate"><span class="pre">a</span></code>
is bound to a value from the second struct in the array of structs.</p>
</section>
<section id="tuples">
<span id="syntax-tuples"></span><h2>Tuples<a class="headerlink" href="#tuples" title="Link to this heading">¶</a></h2>
<p>A tuple is a finite, ordered, unchangeable list of elements. It is represented as a
comma-separated list of elements enclosed by parentheses (e.g., <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">x)</span></code>).
Their elements may be of any combination of valid <a class="reference internal" href="#syntax-type"><span class="std std-ref">types</span></a>. A tuple
that contains only one element must be defined in one of the two following ways: the element is
a named tuple or has a trailing comma. When a tuple is passed as an argument, the type of each
element may be specified on a per-element basis (e.g., <code class="docutils literal notranslate"><span class="pre">my_tuple:</span> <span class="pre">(felt,</span> <span class="pre">felt,</span> <span class="pre">MyStruct)</span></code>).
Tuple values may be accessed with a zero-based index in brackets <code class="docutils literal notranslate"><span class="pre">[index]</span></code>, including access to
nested tuple elements as shown below.</p>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<p>You can define a function as follows:</p>
<p>The implicit argument part <code class="docutils literal notranslate"><span class="pre">{implicit_arg1:</span> <span class="pre">felt,</span> <span class="pre">implicit_arg2:</span> <span class="pre">felt*}</span></code>
and the return value <code class="docutils literal notranslate"><span class="pre">(ret1:</span> <span class="pre">felt,</span> <span class="pre">ret2:</span> <span class="pre">felt)</span></code> are optional.</p>
<p>For more information about functions see <a class="reference internal" href="../how-cairozero-works/functions.html#functions"><span class="std std-ref">Functions</span></a> and <a class="reference internal" href="../how-cairozero-works/builtins.html#implicit-arguments"><span class="std std-ref">Implicit arguments</span></a>.</p>
</section>
<section id="return-statement">
<h2>Return statement<a class="headerlink" href="#return-statement" title="Link to this heading">¶</a></h2>
<p>A function must end with a <code class="docutils literal notranslate"><span class="pre">return</span></code> statement, which takes the following form:</p>
<p>Return values may either be positional or named, where positional values are identified
by the order in which they appear in the <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">()</span></code> syntax. Positional arguments
must appear before named arguments.</p>
</section>
<section id="function-return-values">
<h2>Function return values<a class="headerlink" href="#function-return-values" title="Link to this heading">¶</a></h2>
<p>A function can return values to the caller function. The return values are
designated by the <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">()</span></code> syntax.</p>
<p>Functions can specify that a return value should be of a specific type.
The function below returns two values, <code class="docutils literal notranslate"><span class="pre">a</span></code>, a value of type <code class="docutils literal notranslate"><span class="pre">felt</span></code>
and <code class="docutils literal notranslate"><span class="pre">b</span></code>, a pointer.</p>
</section>
<section id="call-statement">
<h2>Call statement<a class="headerlink" href="#call-statement" title="Link to this heading">¶</a></h2>
<p>You can call a function in the following ways:</p>
<p>Option (1) can be used when there is no return value or it should be ignored.</p>
<p>Option (2) binds <code class="docutils literal notranslate"><span class="pre">x</span></code> to the return value struct.</p>
<p>Option (3) unpacks the return value into <code class="docutils literal notranslate"><span class="pre">ret1</span></code> and <code class="docutils literal notranslate"><span class="pre">ret2</span></code>.</p>
<p>Option (4) is a tail recursion – after <code class="docutils literal notranslate"><span class="pre">foo</span></code> returns, the calling function returns the
same return value.</p>
</section>
<section id="scope-attributes">
<h2>Scope attributes<a class="headerlink" href="#scope-attributes" title="Link to this heading">¶</a></h2>
<p>You can define a string attribute for a code block by surrounding it with a <code class="docutils literal notranslate"><span class="pre">with_attr</span></code> statement
as follows:</p>
<p>See <a class="reference internal" href="../how-cairozero-works/scope_attributes.html#scope-attributes"><span class="std std-ref">Scope attributes</span></a> for more information.</p>
</section>
<section id="library-imports">
<h2>Library imports<a class="headerlink" href="#library-imports" title="Link to this heading">¶</a></h2>
<p>Library functions are imported at the top of the file or right below the <code class="docutils literal notranslate"><span class="pre">%builtins</span></code>
directive if it is used. The statement consists of the module name and the functions to
<code class="docutils literal notranslate"><span class="pre">import</span></code> from it. Multiple functions from the same library can be separated by commas.
Functions from different libraries are imported on different lines. Cairo searches each
module in a default directory path and in any additional paths specified at compile time.
See <a class="reference internal" href="../how-cairozero-works/imports.html#import-search-path"><span class="std std-ref">Import search paths</span></a> for more information.</p>
</section>
<section id="implicit-arguments">
<span id="syntax-implicit-arguments"></span><h2>Implicit arguments<a class="headerlink" href="#implicit-arguments" title="Link to this heading">¶</a></h2>
<p>Implicit arguments are specified as part of the function signature, and are declared
inside curly braces <code class="docutils literal notranslate"><span class="pre">{implicit_arg_name}</span></code>. Implicit arguments are automatically added as an
argument and a return value to the function. The Cairo compiler takes care to return the
current binding of the reference
<code class="docutils literal notranslate"><span class="pre">implicit_arg_name</span></code>. If no implicit arguments are required the braces can be omitted.</p>
<p>The function above, which is available in the common library, accepts an impicit argument,
<code class="docutils literal notranslate"><span class="pre">output_ptr</span></code>, whose new binding is implicitly added as a return value.</p>
<p>Note that it was not necessary to explicitly pass the implicit argument via
<code class="docutils literal notranslate"><span class="pre">serialize_word{output_ptr=output_ptr}(value=5)</span></code>, since the parent function <code class="docutils literal notranslate"><span class="pre">main()</span></code>
already has a binding for <code class="docutils literal notranslate"><span class="pre">output_ptr</span></code> and the compiler will automatically pass it to
<code class="docutils literal notranslate"><span class="pre">serialize_word()</span></code>. For more information, see <a class="reference internal" href="../how-cairozero-works/builtins.html#implicit-arguments"><span class="std std-ref">Implicit arguments</span></a>.</p>
</section>
<section id="builtins">
<h2>Builtins<a class="headerlink" href="#builtins" title="Link to this heading">¶</a></h2>
<p>Builtin declarations appear at the top of the Cairo code file. They are declared with the
<code class="docutils literal notranslate"><span class="pre">%builtins</span></code> directive, followed by the name of the builtins.
A builtin is utilized by writing the inputs to a dedicated memory segment accessed via the
builtin pointer. The builtin directive adds those pointers as
parameters to main (abstracted in StarkNet contracts), which can then be passed to any
function making use of them.</p>
<p>Pointer names follow the convention <code class="docutils literal notranslate"><span class="pre">&lt;builtin</span> <span class="pre">name&gt;_ptr</span></code>
and pointer types can be found in the <code class="docutils literal notranslate"><span class="pre">cairo_builtins</span></code>
module of the common library. The builtins, and their respective pointer expressions and
pointer types are listed below.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code>, for writing program output which appears explicitly in an execution proof.
Access with a pointer to type <code class="docutils literal notranslate"><span class="pre">felt</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pedersen</span></code>, for computing the Pedersen hash function. Access with a pointer to
type <code class="docutils literal notranslate"><span class="pre">HashBuiltin</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">range_check</span></code>, for checking that a field element is within a range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2^128)</span></code>,
and doing various comparisons.
Due to historical reasons, unlike <code class="docutils literal notranslate"><span class="pre">output_ptr</span></code>, the <code class="docutils literal notranslate"><span class="pre">range_check_ptr</span></code> passed as an
argument to main is of type <code class="docutils literal notranslate"><span class="pre">felt</span></code> rather than <code class="docutils literal notranslate"><span class="pre">felt*</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ecdsa</span></code>, for verifying ECDSA signatures. Access with a pointer to type <code class="docutils literal notranslate"><span class="pre">SignatureBuiltin</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bitwise</span></code>, for performing bitwise operations on felts. Access with a pointer to
type <code class="docutils literal notranslate"><span class="pre">BitwiseBuiltin</span></code>.</p></li>
</ul>
<p>Below is a function, <code class="docutils literal notranslate"><span class="pre">foo()</span></code>, which accepts all five builtins, illustrating their
different pointers and pointer types. Note that the pointers must be passed in the
same order that they appear in the <code class="docutils literal notranslate"><span class="pre">%builtins</span></code> directive and that the order follows
the convention:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pedersen</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">range_check</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ecdsa</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bitwise</span></code>.</p></li>
</ol>
<p>For more information about builtins see <a class="reference internal" href="../how-cairozero-works/builtins.html#builtins"><span class="std std-ref">Builtins and implicit arguments</span></a>, and the <code class="docutils literal notranslate"><span class="pre">cairo_builtins</span></code>
section in the common library.</p>
</section>
<section id="segments">
<h2>Segments<a class="headerlink" href="#segments" title="Link to this heading">¶</a></h2>
<p>When running the Cairo code, the memory is separated into different sections called segments.
For example, each builtin occupies a different memory segment. The memory locations are
designated by two numbers, a segment index and an offset in the segment.
In this format, these numbers are separated by a colon <code class="docutils literal notranslate"><span class="pre">:</span></code>.
When the program ends, the segments are glued and each value of the form <code class="docutils literal notranslate"><span class="pre">*:*</span></code>
is replaced with a number. See <a class="reference internal" href="../how-cairozero-works/segments.html#segments"><span class="std std-ref">Segments</span></a> for more information. Some examples
of segments and their interpretation are listed below:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0:3</span></code>, memory address 3 within segment 0.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1:7</span></code>, memory address 7 within segment 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:12</span></code>, memory address 12 within segment 2.</p></li>
</ul>
</section>
<section id="program-input">
<h2>Program input<a class="headerlink" href="#program-input" title="Link to this heading">¶</a></h2>
<p>Program inputs can be accessed within hints using the (hint) variable <code class="docutils literal notranslate"><span class="pre">program_input</span></code>.
A Cairo program can be run with the <code class="docutils literal notranslate"><span class="pre">--program_input</span></code> flag, which allows providing a json
input file that can be referenced inside the hints.
See <a class="reference internal" href="../how-cairozero-works/program_input_and_output.html#program-inputs"><span class="std std-ref">Program input</span></a> for more information.</p>
</section>
<section id="jumps">
<h2>Jumps<a class="headerlink" href="#jumps" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">jmp</span></code> instruction allows navigating through the program, either moving to a
specific label via <code class="docutils literal notranslate"><span class="pre">jmp</span> <span class="pre">LABEL;</span></code>, or a specific location defined by a value of the program counter.
This may be an absolute value with <code class="docutils literal notranslate"><span class="pre">jmp</span> <span class="pre">abs</span> <span class="pre">VALUE;</span></code> or an offset relative to the current
instruction with <code class="docutils literal notranslate"><span class="pre">jmp</span> <span class="pre">rel</span> <span class="pre">OFFSET;</span></code>.
Cairo supports conditional jumps with the syntax <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">&lt;expr&gt;</span> <span class="pre">!=</span> <span class="pre">0</span></code> following a jump instruction.
It is preferable to use <code class="docutils literal notranslate"><span class="pre">if</span></code> rather than <code class="docutils literal notranslate"><span class="pre">jmp</span></code> where possible. An example use of <code class="docutils literal notranslate"><span class="pre">if</span></code> can be
seen here <a class="reference internal" href="#syntax-reference"><span class="std std-ref">References</span></a>.</p>
<p>When the jump condition depends on a value that is determined by the prover, it
gets to decide whether or not the jump is executed, de facto making this a non deterministic jump.</p>
<p>See <a class="reference internal" href="../how-cairozero-works/non_deterministic_jumps.html#non-deterministic-jumps"><span class="std std-ref">Nondeterministic jumps</span></a> for more information.</p>
</section>
<section id="program-output">
<h2>Program output<a class="headerlink" href="#program-output" title="Link to this heading">¶</a></h2>
<p>Cairo programs can share information with the verifier using outputs. Whenever the program
wishes to communicate information to the verifier, it can do so by writing it to a designated
memory segment which can be accessed by using the output builtin. Instead of directly handling
the output pointer, one can call the <code class="docutils literal notranslate"><span class="pre">serialize_word()</span></code> library function which abstracts
this from the user. Note that in real applications there is only need to output information
if it’s meaningful in some way for the verifier. See <a class="reference internal" href="../how-cairozero-works/program_input_and_output.html#program-output"><span class="std std-ref">here</span></a> for more
information.</p>
<p>The following program outputs two values, 7 and 13.</p>
<p>The following program excerpt outlines how a program may output a struct.</p>
</section>
<section id="hints">
<h2>Hints<a class="headerlink" href="#hints" title="Link to this heading">¶</a></h2>
<p>Python code can be invoked with the <code class="docutils literal notranslate"><span class="pre">%{</span></code> <code class="docutils literal notranslate"><span class="pre">%}</span></code> block called a hint, which is executed right
before the next Cairo instruction. The hint can interact
with the program’s variables/memory as shown in the following code sample.
Note that the hint is not actually part of the Cairo program,
and can thus be replaced by a malicious prover. We can run a Cairo program with
the <code class="docutils literal notranslate"><span class="pre">--program_input</span></code> flag, which allows providing a json input file that
can be referenced inside a hint.</p>
<p>Note that you can access the address of a pointer to a struct using <code class="docutils literal notranslate"><span class="pre">ids.struct_ptr.address_</span></code>
and you can use <code class="docutils literal notranslate"><span class="pre">memory[addr]</span></code> for the value of the memory cell at address <code class="docutils literal notranslate"><span class="pre">addr</span></code>.</p>
</section>
<section id="unpacking">
<h2>Unpacking<a class="headerlink" href="#unpacking" title="Link to this heading">¶</a></h2>
<p>The values returned by a function can be ignored, or bound, to either a reference or local
variable. The <code class="docutils literal notranslate"><span class="pre">_</span></code> character is used to handle returned values that are ignored.
Consider the function <code class="docutils literal notranslate"><span class="pre">foo()</span></code> that returns two values.</p>
<p>For more information see <a class="reference internal" href="../how-cairozero-works/functions.html#return-values-unpacking"><span class="std std-ref">Return values unpacking</span></a>.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Cairo Documentation (Cairo 0)</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Cairo Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Setting up the environment</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../hello-cairozero/index.html">Hello, Cairo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how-cairozero-works/index.html">How Cairo Works</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="common_library.html">Common Library</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../sharp.html">Using SHARP (Shared Prover)</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Reference</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Reference</a></li>
      <li>Next: <a href="common_library.html" title="next chapter">Common Library</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/reference/syntax.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>