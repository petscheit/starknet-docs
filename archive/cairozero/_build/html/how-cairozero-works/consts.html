<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Consts and references &#8212; Cairo Documentation (Cairo 0)  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Functions" href="functions.html" />
    <link rel="prev" title="The program counter (pc)" href="program_counter.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="consts-and-references">
<h1>Consts and references<a class="headerlink" href="#consts-and-references" title="Link to this heading">¶</a></h1>
<section id="consts">
<h2>Consts<a class="headerlink" href="#consts" title="Link to this heading">¶</a></h2>
<p>Cairo supports defining constant expressions (only integers).
For example, one may write:</p>
<p>which is equivalent to</p>
<p>The line <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">value</span> <span class="pre">=</span> <span class="pre">1234</span></code> is not translated to a Cairo instruction;
it is just used by the compiler to replace <code class="docutils literal notranslate"><span class="pre">value</span></code> with <code class="docutils literal notranslate"><span class="pre">1234</span></code> in the following instructions.</p>
</section>
<section id="short-string-literals">
<span id="id1"></span><h2>Short string literals<a class="headerlink" href="#short-string-literals" title="Link to this heading">¶</a></h2>
<p>A short string is a string whose length is at most 31 characters, and therefore can fit into
a single field element.</p>
<p>which is equivalent to</p>
<p>It is important to note that a short-string is simply a way to represent a field element,
it’s not a real string.
Cairo doesn’t support strings at the moment, and when it does, strings will be represented using
<code class="docutils literal notranslate"><span class="pre">&quot;</span></code> rather than <code class="docutils literal notranslate"><span class="pre">'</span></code> (similar to the distinction in C/C++).</p>
<p>The string’s first character is the most significant byte of the integer (big endian
representation).</p>
</section>
<section id="references">
<span id="id2"></span><h2>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<p>Sometimes it may be difficult to follow the progress of the <code class="docutils literal notranslate"><span class="pre">ap</span></code> register.
Consider the following code, which computes <span class="math notranslate nohighlight">\(x^{16}+x\)</span> for <span class="math notranslate nohighlight">\(x = 3\)</span>:</p>
<p>The problem is that it’s difficult to say whether the offset <code class="docutils literal notranslate"><span class="pre">5</span></code> in the last line should indeed be
<code class="docutils literal notranslate"><span class="pre">5</span></code> (rather than <code class="docutils literal notranslate"><span class="pre">4</span></code> or <code class="docutils literal notranslate"><span class="pre">6</span></code>). Instead, we can write:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">let</span></code> syntax defines a <em>reference</em> and this code compiles exactly to the same instructions
as the previous code.
In particular, the compiler replaces the first occurrence of <code class="docutils literal notranslate"><span class="pre">[x]</span></code> by <code class="docutils literal notranslate"><span class="pre">[ap]</span></code> and the second
by <code class="docutils literal notranslate"><span class="pre">[ap</span> <span class="pre">-</span> <span class="pre">5]</span></code>. In other words, the compiler tracks the progress of the <code class="docutils literal notranslate"><span class="pre">ap</span></code> register and
substitutes <code class="docutils literal notranslate"><span class="pre">x</span></code> accordingly.</p>
<p>References can hold any Cairo expression, for example:</p>
</section>
<section id="the-assert-statement-and-compound-expressions">
<span id="compound-expressions"></span><span id="assert-statement"></span><h2>The assert statement and compound expressions<a class="headerlink" href="#the-assert-statement-and-compound-expressions" title="Link to this heading">¶</a></h2>
<p>Often you’ll need to perform a computation which involves more than one operation.
The polynomial in <a class="reference internal" href="cairo_intro.html#a-simple-cairo-program-exercise"><span class="std std-ref">Exercise - A simple Cairo program</span></a> is a good example.
An expression that involves more than one operation (e.g., <code class="docutils literal notranslate"><span class="pre">[ap]</span> <span class="pre">*</span> <span class="pre">[ap]</span> <span class="pre">*</span> <span class="pre">[ap]</span></code>,
<code class="docutils literal notranslate"><span class="pre">[[[ap]]]</span> <span class="pre">+</span> <span class="pre">[ap]</span></code>, …) is called a <em>compound expression</em>.
The Cairo compiler supports the following syntax, which allows to assert the equality between the
values of two compound expressions:</p>
<p>For example,</p>
<p>Note that such statements are usually compiled to more than one instruction and <code class="docutils literal notranslate"><span class="pre">ap</span></code> may
advance an unknown number of steps (the exact number depends on the number of operations in the two
compound expressions). Hence, <strong>you should avoid</strong> using <code class="docutils literal notranslate"><span class="pre">ap</span></code> and
<code class="docutils literal notranslate"><span class="pre">fp</span></code> directly in such expressions and use the mechanisms presented in this section instead
(<a class="reference internal" href="#references"><span class="std std-ref">references</span></a> and <a class="reference internal" href="#tempvars"><span class="std std-ref">temporary</span></a>/<a class="reference internal" href="#local-vars"><span class="std std-ref">local</span></a>
variables).</p>
</section>
<section id="revoked-references">
<span id="id3"></span><h2>Revoked references<a class="headerlink" href="#revoked-references" title="Link to this heading">¶</a></h2>
<p>Note that if there is a label or a call instruction
(call to another function. See <a class="reference internal" href="functions.html#functions"><span class="std std-ref">Functions</span></a>)
between the definition of a reference
that depends on <code class="docutils literal notranslate"><span class="pre">ap</span></code> and its usage, the reference may be <em>revoked</em>, since the compiler may not
be able to compute the change of <code class="docutils literal notranslate"><span class="pre">ap</span></code> (as one may jump to the label from another place in the
program, or call a function that might change <code class="docutils literal notranslate"><span class="pre">ap</span></code> in an unknown way).</p>
<p>In some cases, the compiler will not automatically detect that a jump may occur
(for example, in an explicit relative jump, see the exercise below)
and the reference will not be revoked.
However, using this reference in such cases may result in an undefined behavior.</p>
<p>References which do not depend on <code class="docutils literal notranslate"><span class="pre">ap</span></code> (for example, <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">[[fp]];</span></code>)
are never revoked by the compiler, but the same rule applies – using those references
outside of the scope of the function they were defined in, may result in an undefined behavior.</p>
<section id="exercise">
<h3>Exercise<a class="headerlink" href="#exercise" title="Link to this heading">¶</a></h3>
<p>Run the following code, with <code class="docutils literal notranslate"><span class="pre">--steps=32</span> <span class="pre">--print_memory</span></code> and explain what happens.</p>
</section>
</section>
<section id="typed-references">
<span id="id4"></span><h2>Typed references<a class="headerlink" href="#typed-references" title="Link to this heading">¶</a></h2>
<p>Suppose that <code class="docutils literal notranslate"><span class="pre">[fp]</span></code> contains a pointer to a struct of three memory cells: x, y, z.
To access the value of y, one may write <code class="docutils literal notranslate"><span class="pre">[[fp]</span> <span class="pre">+</span> <span class="pre">1]</span></code>. However, this requires the programmer
to maintain the offset of y.</p>
<p>A better way is to define a struct:</p>
<p>This creates a struct named <code class="docutils literal notranslate"><span class="pre">MyStruct</span></code>.
The keyword <code class="docutils literal notranslate"><span class="pre">felt</span></code> stands for field element, which is the primitive type in Cairo.
The Cairo compiler computes the offsets of the members from the beginning
of the structs, and you can access those offsets using
<code class="docutils literal notranslate"><span class="pre">MyStruct.x</span></code>, <code class="docutils literal notranslate"><span class="pre">MyStruct.y</span></code> and <code class="docutils literal notranslate"><span class="pre">MyStruct.z</span></code> (for example <code class="docutils literal notranslate"><span class="pre">MyStruct.z</span> <span class="pre">=</span> <span class="pre">2</span></code>).
In addition, the total size of the struct can be obtained using <code class="docutils literal notranslate"><span class="pre">MyStruct.SIZE</span></code>.
Now we can replace <code class="docutils literal notranslate"><span class="pre">[[fp]</span> <span class="pre">+</span> <span class="pre">1]</span></code> with <code class="docutils literal notranslate"><span class="pre">[[fp]</span> <span class="pre">+</span> <span class="pre">MyStruct.y]</span></code>.</p>
<p>Since this pattern repeats itself quite a lot, Cairo supports defining typed references
as follows:</p>
<p>In general, the syntax <code class="docutils literal notranslate"><span class="pre">refname.member_name</span></code>, where <code class="docutils literal notranslate"><span class="pre">refname</span></code> is a typed reference
with value <code class="docutils literal notranslate"><span class="pre">val</span></code> and type <code class="docutils literal notranslate"><span class="pre">T</span></code>, and <code class="docutils literal notranslate"><span class="pre">T.member_name</span></code> is a member definition,
compiles to <code class="docutils literal notranslate"><span class="pre">[val</span> <span class="pre">+</span> <span class="pre">T.member_name]</span></code>.</p>
<p>You may omit the type and write (the Cairo compiler will deduce the type from the right-hand side):</p>
</section>
<section id="casting">
<span id="id5"></span><h2>Casting<a class="headerlink" href="#casting" title="Link to this heading">¶</a></h2>
<p>Every Cairo expression has an associated type. Cairo supports types such as field-element
(represented by the keyword <code class="docutils literal notranslate"><span class="pre">felt</span></code>), pointers and structs.
For example, the type of the values of the
registers <code class="docutils literal notranslate"><span class="pre">ap</span></code> and <code class="docutils literal notranslate"><span class="pre">fp</span></code> and any integer literal is <code class="docutils literal notranslate"><span class="pre">felt</span></code>.</p>
<p>You can change the type of an expression using <code class="docutils literal notranslate"><span class="pre">cast(&lt;expr&gt;,</span> <span class="pre">&lt;type&gt;)</span></code>, where <code class="docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code> can be
<code class="docutils literal notranslate"><span class="pre">felt</span></code> (for a field-element), <code class="docutils literal notranslate"><span class="pre">T</span></code> (for a struct <code class="docutils literal notranslate"><span class="pre">T</span></code>, as explained above) or a pointer to
another type (such as <code class="docutils literal notranslate"><span class="pre">T*</span></code> or <code class="docutils literal notranslate"><span class="pre">felt**</span></code>).</p>
</section>
<section id="temporary-variables">
<span id="tempvars"></span><h2>Temporary variables<a class="headerlink" href="#temporary-variables" title="Link to this heading">¶</a></h2>
<p>Cairo supports the following syntactic sugar which allows defining temporary variables:</p>
<p>For simple expressions, with at most one operation, this is equivalent to:</p>
<p><a class="reference internal" href="#compound-expressions"><span class="std std-ref">Compound expressions</span></a> are also supported, in which case the command
may be compiled to more than one Cairo instruction.</p>
<p>Note that as the reference is based on <code class="docutils literal notranslate"><span class="pre">ap</span></code>, it may be revoked by some instructions
(see <a class="reference internal" href="#revoked-references"><span class="std std-ref">Revoked references</span></a>).</p>
<section id="id6">
<h3>Exercise<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h3>
<p>Rewrite the solution to <a class="reference internal" href="cairo_intro.html#a-simple-cairo-program-exercise"><span class="std std-ref">Exercise - A simple Cairo program</span></a> using temporary variables.</p>
</section>
</section>
<section id="local-variables">
<span id="local-vars"></span><h2>Local variables<a class="headerlink" href="#local-variables" title="Link to this heading">¶</a></h2>
<p>Another important feature is called “local variables”. Unlike <a class="reference internal" href="#tempvars"><span class="std std-ref">Temporary variables</span></a> which are based
on the <code class="docutils literal notranslate"><span class="pre">ap</span></code> register, and thus are revoked by some instructions (see <a class="reference internal" href="#revoked-references"><span class="std std-ref">Revoked references</span></a>),
local variables are based on the <code class="docutils literal notranslate"><span class="pre">fp</span></code> register. In the scope of a function, the first local
variable will be a reference to <code class="docutils literal notranslate"><span class="pre">[fp</span> <span class="pre">+</span> <span class="pre">0]</span></code>, the second one to <code class="docutils literal notranslate"><span class="pre">[fp</span> <span class="pre">+</span> <span class="pre">1]</span></code> and so on.
Unlike <a class="reference internal" href="#tempvars"><span class="std std-ref">Temporary variables</span></a> which take care of incrementing <code class="docutils literal notranslate"><span class="pre">ap</span></code>, this is not the case for local
variables. You must take care to advance <code class="docutils literal notranslate"><span class="pre">ap</span></code> if you’re using local variables.
The Cairo compiler auto-generates a constant <code class="docutils literal notranslate"><span class="pre">SIZEOF_LOCALS</span></code> which is equal to the
accumulated size (of cells) of locals within the same scope. For example:</p>
<p>Additionally, Cairo provides the instruction <code class="docutils literal notranslate"><span class="pre">alloc_locals</span></code> which is transformed to
<code class="docutils literal notranslate"><span class="pre">ap</span> <span class="pre">+=</span> <span class="pre">SIZEOF_LOCALS</span></code>.</p>
<p>You may also define a local variable and assign a value to it in a single line:</p>
<p>In fact, the expression may be a <a class="reference internal" href="#compound-expressions"><span class="std std-ref">compound expression</span></a>.</p>
<p>Note that unless the local variable is initialized in the same line,
the <code class="docutils literal notranslate"><span class="pre">local</span></code> directive itself does not translate to a Cairo instruction
(this is another difference from <code class="docutils literal notranslate"><span class="pre">tempvar</span></code>) – it simply translates to a reference definition.
This is one of the reasons you must increase the value of <code class="docutils literal notranslate"><span class="pre">ap</span></code> manually.</p>
<p>A local variable may have a type, like a reference.
In the current version of Cairo, the type of a local variable must be explicitly
stated (otherwise, <code class="docutils literal notranslate"><span class="pre">felt</span></code> is used), and it is not deduced from the type of the
initialization value.</p>
<section id="id7">
<h3>Exercise<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>What’s wrong with the following code?
(Hint: try to replace <code class="docutils literal notranslate"><span class="pre">ap</span> <span class="pre">+=</span> <span class="pre">SIZEOF_LOCALS;</span></code> with <code class="docutils literal notranslate"><span class="pre">alloc_locals;</span></code> and see what happens)
Can you fix it without changing the order of the variable definitions in the code?</p></li>
<li><p>Can you spot an inefficiency in the following code? Hint: take a look
<a class="reference internal" href="cairo_intro.html#continuous-memory"><span class="std std-ref">here</span></a>.
Fix the inefficiency in two ways (implement each of the following fixes separately):</p>
<ol class="loweralpha simple">
<li><p>Move the instruction <code class="docutils literal notranslate"><span class="pre">alloc_locals;</span></code>.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">tempvar</span></code> instead of <code class="docutils literal notranslate"><span class="pre">local</span></code>.</p></li>
</ol>
</li>
</ol>
</section>
</section>
<section id="typed-local-variables">
<h2>Typed local variables<a class="headerlink" href="#typed-local-variables" title="Link to this heading">¶</a></h2>
<p>You can specify a type for the local variable in two different ways:</p>
<p>The first one allocates one cell, which will be considered a pointer to a struct of type <code class="docutils literal notranslate"><span class="pre">T</span></code>.
Thus you can use <code class="docutils literal notranslate"><span class="pre">x.a</span></code> as an equivalent to <code class="docutils literal notranslate"><span class="pre">[[fp</span> <span class="pre">+</span> <span class="pre">0]</span> <span class="pre">+</span> <span class="pre">T.a]</span></code>
(assuming <code class="docutils literal notranslate"><span class="pre">a</span></code> is a member of <code class="docutils literal notranslate"><span class="pre">T</span></code>).</p>
<p>The second one allocates <code class="docutils literal notranslate"><span class="pre">T.SIZE</span></code> cells
(starting from <code class="docutils literal notranslate"><span class="pre">fp</span> <span class="pre">+</span> <span class="pre">1</span></code> in the example above due to the definition of <code class="docutils literal notranslate"><span class="pre">x</span></code>),
and in this case <code class="docutils literal notranslate"><span class="pre">y.a</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">[fp</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">T.a]</span></code> rather than <code class="docutils literal notranslate"><span class="pre">[[fp</span> <span class="pre">+</span> <span class="pre">1]</span> <span class="pre">+</span> <span class="pre">T.a]</span></code>
(exercise: why?).</p>
<p>Moreover, <code class="docutils literal notranslate"><span class="pre">y</span></code> itself refers to the <em>address</em> of the struct (<code class="docutils literal notranslate"><span class="pre">fp</span> <span class="pre">+</span> <span class="pre">1</span></code> rather than <code class="docutils literal notranslate"><span class="pre">[fp</span> <span class="pre">+</span> <span class="pre">1]</span></code>).
This means you may get an error if you try to use <code class="docutils literal notranslate"><span class="pre">y</span></code>. For example:</p>
<p>will fail, since it should compile to <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">[ap]</span> <span class="pre">=</span> <span class="pre">fp</span> <span class="pre">+</span> <span class="pre">1,</span> <span class="pre">ap++;</span></code> which is not a valid
instruction in Cairo due to the use of <code class="docutils literal notranslate"><span class="pre">fp</span></code>. Nevertheless, defining a variable called <code class="docutils literal notranslate"><span class="pre">__fp__</span></code>
will allow the code to compile, as you will see in <a class="reference internal" href="functions.html#retrieving-registers"><span class="std std-ref">Accessing the values of the registers</span></a>.</p>
</section>
<section id="reference-rebinding">
<span id="id8"></span><h2>Reference rebinding<a class="headerlink" href="#reference-rebinding" title="Link to this heading">¶</a></h2>
<p>Cairo allows you to define a reference with the name of an existing reference:</p>
<p><strong>References are not variables:</strong> the scope of each definition is defined according to
<strong>a static analysis</strong> of the order in which the instructions will be executed. It will follow a
basic flow from jumps and conditional jumps, but if there are colliding definitions for the same
reference, the reference will be revoked.</p>
<section id="example">
<h3>Example<a class="headerlink" href="#example" title="Link to this heading">¶</a></h3>
<p>To stress this last point, consider the following code.</p>
<p>This code will return either <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code>, or <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">3]</span></code>.</p>
</section>
</section>
<section id="tuples">
<span id="id9"></span><h2>Tuples<a class="headerlink" href="#tuples" title="Link to this heading">¶</a></h2>
<p>Tuples allow convenient referencing of an ordered collection of elements. Tuples consist of any
combination of valid types, including other tuples.</p>
<p>Tuples are represented as a comma-separated list of elements enclosed in parentheses.
For example: <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">x)</span></code>.</p>
<p>Consider the following assert statement:</p>
<p>The above statement compiles to:</p>
<p>See <a class="reference internal" href="types.html#tuple-types"><span class="std std-ref">Tuples</span></a> for more information about the type of a tuple expression.</p>
<p>Tuple elements are accessed with the tuple expression followed by brackets containing a zero-based
index to the element. The index must be known at compile time.</p>
<p>Cairo requires a trailing comma for single-element tuples, to distinguish them from regular
parentheses. For example <code class="docutils literal notranslate"><span class="pre">(5,)</span></code> is a single-element tuple. Access to nested tuples is achieved by
using additional indices starting with the outer-most tuple. For example, <code class="docutils literal notranslate"><span class="pre">MyTuple[2][4][3][1]</span></code>
first accesses index 2 of <code class="docutils literal notranslate"><span class="pre">MyTuple</span></code>. This value is accessed at index 4, and so on.</p>
</section>
<section id="arrays">
<span id="id10"></span><h2>Arrays<a class="headerlink" href="#arrays" title="Link to this heading">¶</a></h2>
<p>In order to represent an array (an ordered collection of homogeneous elements) in Cairo, one may
use a pointer to the beginning of the array. See <a class="reference internal" href="object_allocation.html#alloc"><span class="std std-ref">alloc()</span></a> for allocating a new memory segment
for arrays.</p>
<p>The expression <code class="docutils literal notranslate"><span class="pre">struct_array[n]</span></code> is used to access the n-th element of the array,
where n=0 is the first element. <code class="docutils literal notranslate"><span class="pre">struct_array[index]</span></code> is compiled to
<code class="docutils literal notranslate"><span class="pre">[struct_array</span> <span class="pre">+</span> <span class="pre">index</span> <span class="pre">*</span> <span class="pre">MyStruct.SIZE]</span></code>, and is of type <code class="docutils literal notranslate"><span class="pre">MyStruct</span></code>.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Cairo Documentation (Cairo 0)</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Cairo Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Setting up the environment</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../hello-cairozero/index.html">Hello, Cairo</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">How Cairo Works</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="cairo_intro.html">Introduction to Cairo</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging_tricks.html">Debugging-related flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="program_counter.html">The program counter (pc)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Consts and references</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="object_allocation.html">Object allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="scope_attributes.html">Scope attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="imports.html">Imports</a></li>
<li class="toctree-l2"><a class="reference internal" href="hints.html">Hints</a></li>
<li class="toctree-l2"><a class="reference internal" href="program_input_and_output.html">Program input &amp; output</a></li>
<li class="toctree-l2"><a class="reference internal" href="segments.html">Segments</a></li>
<li class="toctree-l2"><a class="reference internal" href="non_deterministic_jumps.html">Nondeterministic jumps</a></li>
<li class="toctree-l2"><a class="reference internal" href="builtins.html">Builtins and implicit arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="define_word.html">Define word</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sharp.html">Using SHARP (Shared Prover)</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">How Cairo Works</a><ul>
      <li>Previous: <a href="program_counter.html" title="previous chapter">The program counter (pc)</a></li>
      <li>Next: <a href="functions.html" title="next chapter">Functions</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/how-cairozero-works/consts.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>