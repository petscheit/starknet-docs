---
title: "core::starknet::storage"
---


Storage-related types and traits for Cairo contracts.
This module implements the storage system for Starknet contracts, providing high-level
abstractions for persistent data storage. It offers a type-safe interface for reading and
writing to Starknet storage through the `StoragePointerReadAccess` and
`StoragePointerWriteAccess` traits, along with useful storage-only collection types like
[`Vec`](./core-starknet-storage-vec-Vec) and [`Map`](./core-starknet-storage-map-Map).
# Overview

The storage system in Starknet contracts is built on a key-value store where each storage slot
is identified by a 251-bit address. The storage system allows interactions with storage using
state variables, which are declared inside a `Storage` struct annotated with the `#[storage]`
attribute. This ensures type-safe storage access and simplifies the process of reading and
writing to storage.
# Using the Storage System

Storage is typically declared using the `#[storage]` attribute on a struct:
```rust
#[storage]
struct Storage {
    balance: u256,
    users: Map,
    nested_data: Map>,
    collection: Vec,
}
```

Any type that implements the `Store` trait (or it's optimized `StorePacked` variant) can be used
in storage.  This type can simply be derived using `#[derive(Store)]` - provided that all of the
members of the type also implement `Store`.
```rust
#[derive(Copy, Default, Drop, Store)]
struct User {
    name: felt252,
    age: u8,
}
```

Interaction with storage is made through a set of traits, depending on the type interacted
with:
- `StoragePointerReadAccess` and `StoragePointerWriteAccess` allow for reading and writing
storable types.
- [`StorageMapReadAccess`](./core-starknet-storage-map-StorageMapReadAccess) and [`StorageMapWriteAccess`](./core-starknet-storage-map-StorageMapWriteAccess) allow for reading and writing to
storage [`Map`](./core-starknet-storage-map-Map)s.
- [`StoragePathEntry`](./core-starknet-storage-map-StoragePathEntry) allows for accessing a specific entry in a [`Map`](./core-starknet-storage-map-Map), and can be combined
with the `StoragePointer` traits to read and write in these entries.
- [`VecTrait`](./core-starknet-storage-vec-VecTrait) and [`MutableVecTrait`](./core-starknet-storage-vec-MutableVecTrait) allow for interacting with storage [`Vec`](./core-starknet-storage-vec-Vec)s.
## Examples

```rust
fn use_storage(self: @ContractState) {
    let address = 'address'.try_into().unwrap();
    // Reading values
    let balance = self.balance.read();
    // For a `Map`, use the `entry` method to access values at specific keys:
    let user = self.users.entry(address).read();
    // Accessing nested `Map`s requires chaining `entry` calls:
    let nested = self.nested_data.entry(address).entry(address).read();
    // Accessing a specific index in a `Vec` requires using the `index` method:
    let element = self.collection[index];

    // Writing values
    self.balance.write(100);
    self.users.entry(address).write(Default::default());
    self.nested_data.entry(address).entry(address).write(10);
    self.collection[index].write(20);
}
```
# Storage Lifecycle

When you access a storage variable, it goes through several transformations:

1. FlattenedStorage: The starting point is your contract's storage struct. Each member is
represented either as a `StorageBase` or another `FlattenedStorage` (for `#[substorage(v0)]`
or `#[flat]` members).

2. StorageBase: For simple variables, this holds the `sn_keccak` hash of the variable name,
which becomes the storage address. For example:
```rust
#[storage]
struct Storage {
    balance: u128,  // Stored at sn_keccak('balance')
}
```


3. StoragePath: For complex types, a `StoragePath` represents an un-finalized path to a
specific entry in storage. For example, a `StoragePath` for a `Map` can be updated with
specific keys to point to a specific entry in the map.

4. StoragePointer: The final form, pointing to the actual storage location. For multi-slot
values (like structs), values are stored sequentially from this address.
# Storage Collections

Cairo's memory collection types, like `Felt252Dict` and [`Array`](./core-array-Array), can not be used in storage.
Consequently, any type that contains these types can not be used in storage either.
Instead, Cairo has two storage-only collection types: [`Map`](./core-starknet-storage-map-Map) and [`Vec`](./core-starknet-storage-vec-Vec).
Instead of storing these memory collections directly, you will need to reflect them into
storage using the [`Map`](./core-starknet-storage-map-Map) and [`Vec`](./core-starknet-storage-vec-Vec) types.
# Address Calculation

Storage addresses are calculated deterministically:

- For a single value variable, the address is the `sn_keccak` hash of the variable name's ASCII
encoding. `sn_keccak` is Starknet's version of the Keccak-256 hash function, with its output
truncated to 250 bits.

- For variables composed of multiple values (tuples, structs, or enums), the base storage
address is also the `sn_keccak` hash of the variable name's ASCII encoding. The storage layout
then varies depending on the specific type. A struct will store its members as a sequence of
primitive types, while an enum will store its variant index, followed by the members of the
variant.

- For variables within a storage node, the address is calculated using a chain of hashes that
represents the node structure. Given a member `m` within a storage variable `variable_name`,
the path is computed as `h(sn_keccak(variable_name), sn_keccak(m))`, where `h` is the Pedersen
hash. For nested storage nodes, this process repeats, creating a hash chain representing the
path to each leaf node. At the leaf node, the storage calculation follows the standard rules for
that variable type.

- For [`Map`](./core-starknet-storage-map-Map) or [`Vec`](./core-starknet-storage-vec-Vec) variables, the address is calculated relative to the storage base
address (the `sn_keccak` hash of the variable name) combined with the mapping keys or vector
indices.
See their respective module documentation for more details.



## [Modules](./core-starknet-storage-modules)

| | |
|:---|:---|
| [map](./core-starknet-storage-map) | Key-value storage mapping implementation for Starknet contracts. This module provides the core mapping functionality used in Starknet smart contracts,... |
| [storage_base](./core-starknet-storage-storage_base) | Core abstractions for contract storage management. This module provides the types and traits for handling contract storage internally... |
| [vec](./core-starknet-storage-vec) | Vector-like storage collection for persisting data in contract storage. This module provides a vector-like collection that stores elements in contract storage.... |
| [storage_node](./core-starknet-storage-storage_node) | Storage nodes provide a way to structure contract storage data, reflecting their structure in the storage address computation of their members. They are special structs that can contain any... |
| [sub_pointers](./core-starknet-storage-sub_pointers) | — |

## [Structs](./core-starknet-storage-structs)

| | |
|:---|:---|
| [StoragePointer](./core-starknet-storage-StoragePointer) | A pointer to an address in storage, can be used to read and write values, if the generic type supports it (e.g. basic types like `felt252` ). |
| [StoragePointer0Offset](./core-starknet-storage-StoragePointer0Offset) | Same as `StoragePointer` , but with `offset`  0, which allows for some optimizations. |
| [StoragePath](./core-starknet-storage-StoragePath) | An intermediate struct to store a hash state, in order to be able to hash multiple values and get the final address. Storage path should have two interfaces, if `T`... |
| [PendingStoragePath](./core-starknet-storage-PendingStoragePath) | A struct for delaying the creation of a storage path, used for lazy evaluation in storage nodes. |
| [Mutable](./core-starknet-storage-Mutable) | A wrapper around different storage related types, indicating that the instance is mutable, i.e. originally created from a `ref`  contract state. |

## [Traits](./core-starknet-storage-traits)

| | |
|:---|:---|
| [StorageAsPointer](./core-starknet-storage-StorageAsPointer) | Trait for converting a storage member to a `StoragePointer0Offset` . |
| [StoragePointerReadAccess](./core-starknet-storage-StoragePointerReadAccess) | Trait for accessing the values in storage using a `StoragePointer` .... |
| [StoragePointerWriteAccess](./core-starknet-storage-StoragePointerWriteAccess) | Trait for writing values to storage using a `StoragePointer` .... |
| [StorageAsPath](./core-starknet-storage-StorageAsPath) | Trait for creating a new `StoragePath`  from a storage member. |
| [PendingStoragePathTrait](./core-starknet-storage-PendingStoragePathTrait) | A trait for creating a `PendingStoragePath`  from a `StoragePath`  hash state and a key. |
| [StoragePathMutableConversion](./core-starknet-storage-StoragePathMutableConversion) | — |
| [IntoIterRange](./core-starknet-storage-IntoIterRange) | Trait for turning collection of values into an iterator over a specific range. |
| [ValidStorageTypeTrait](./core-starknet-storage-ValidStorageTypeTrait) | Trait that ensures a type is valid for storage in Starknet contracts. This trait is used to enforce that only specific types, such as those implementing `Store`  or acting as a `StorageNode`... |

## [Impls](./core-starknet-storage-impls)

| | |
|:---|:---|
| [SubPointersDeref](./core-starknet-storage-SubPointersDeref) | This makes the sub-pointers members directly accessible from a pointer to the parent struct. |
| [SubPointersMutDeref](./core-starknet-storage-SubPointersMutDeref) | This makes the sub-pointers members directly accessible from a pointer to the parent struct. |
| [StorableStoragePointerReadAccess](./core-starknet-storage-StorableStoragePointerReadAccess) | Simple implementation of `StoragePointerReadAccess`  for any type that implements `Store`  for any offset. |
| [StorageNodeDeref](./core-starknet-storage-StorageNodeDeref) | This makes the storage node members directly accessible from a path to the parent struct. |
| [StorageNodeMutDeref](./core-starknet-storage-StorageNodeMutDeref) | This makes the storage node members directly accessible from a path to the parent struct. |


---
 
# Re-exports: 

 - ### Structs

| | |
|:---|:---|
| [Map](./core-starknet-storage-map-Map) | A persistent key-value store in contract storage. This type cannot be instantiated as it is marked with `#[phantom]` . This is by design: `Map`... |
| [FlattenedStorage](./core-starknet-storage-storage_base-FlattenedStorage) | A type that represents a flattened storage, i.e. a storage object which does not have any effect on the path taken into consideration when computing the address of the storage object. |
| [StorageBase](./core-starknet-storage-storage_base-StorageBase) | A struct for holding an address to initialize a storage path with. The members (not direct members, but accessible using `deref` ) of a contract state are either `StorageBase`  or `FlattenedStorage`... |
| [Vec](./core-starknet-storage-vec-Vec) | Represents a dynamic array in contract storage. This type is zero-sized and cannot be instantiated. Vectors can only be used in storage contexts and manipulated using the associated `VecTrait` and... |
| [VecIter](./core-starknet-storage-vec-VecIter) | An iterator struct over a `Vec`  in storage. |




 - ### Traits

| | |
|:---|:---|
| [StorageMapReadAccess](./core-starknet-storage-map-StorageMapReadAccess) | Provides direct read access to values in a storage [`Map`](./core-starknet-storage-map-Map) .... |
| [StorageMapWriteAccess](./core-starknet-storage-map-StorageMapWriteAccess) | Provides direct write access to values in a storage [`Map`](./core-starknet-storage-map-Map) . Enables directly storing values in the contract's storage at the address of the given key.... |
| [StoragePathEntry](./core-starknet-storage-map-StoragePathEntry) | Computes storage paths for accessing [`Map`](./core-starknet-storage-map-Map)  entries. The storage path combines the variable's base path with the key's hash to create a unique... |
| [StorageTrait](./core-starknet-storage-storage_base-StorageTrait) | A trait for creating the struct containing the `StorageBase`  or `FlattenedStorage`  of all the members of a contract state. |
| [StorageTraitMut](./core-starknet-storage-storage_base-StorageTraitMut) | A trait for creating the struct containing the mutable `StorageBase`  or `FlattenedStorage`  of all the members of a contract state. |
| [StorageNode](./core-starknet-storage-storage_node-StorageNode) | A trait that given a storage path of a struct, generates the storage node of this struct. |
| [StorageNodeMut](./core-starknet-storage-storage_node-StorageNodeMut) | A mutable version of `StorageNode` , works the same way, but on `Mutable` . |
| [SubPointers](./core-starknet-storage-sub_pointers-SubPointers) | Similar to storage node, but for structs which are stored sequentially in the storage. In contrast to storage node, the fields of the struct are just at an offset from the base address of the struct. |
| [SubPointersForward](./core-starknet-storage-sub_pointers-SubPointersForward) | A trait for implementing `SubPointers`  for types which are not a `StoragePointer` , such as `StorageBase`  and `StoragePath` . |
| [SubPointersMut](./core-starknet-storage-sub_pointers-SubPointersMut) | A mutable version of `SubPointers` , works the same way, but on `Mutable` . |
| [SubPointersMutForward](./core-starknet-storage-sub_pointers-SubPointersMutForward) | A trait for implementing `SubPointersMut`  for types which are not a `StoragePointer` , such as `StorageBase`  and `StoragePath` . |
| [MutableVecTrait](./core-starknet-storage-vec-MutableVecTrait) | Provides mutable access to elements in a storage [`Vec`](./core-starknet-storage-vec-Vec) . This trait extends the read functionality with methods to append new elements and modify existing ones. |
| [VecTrait](./core-starknet-storage-vec-VecTrait) | Provides read-only access to elements in a storage [`Vec`](./core-starknet-storage-vec-Vec) . This trait enables retrieving elements and checking the vector's length without... |



